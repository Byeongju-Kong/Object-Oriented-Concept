# 1) 협력하는 객체들의 공동체

# 객체 지향

- 실세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임
- 실세계에 존재하는 사물들을 최대한 유사하게 모방해 소프트웨어 내부러 옮겨오는 것을 지향
- 실세계의 사물을 기반으로 소프트웨어 객체를 식별하고 구현까지 이어간다는 개념 : 연결완전성(seamlessness)
- 객체 : 실세계에 존재하는 사물에 대한 추상화

→ 하지만 객체 지향의 목적은 실세계를 모방하는 것이 아닌, 그것을 넘어 고객 혹은 사용자가 만족할 만한 새로운 세계를 창조하는 것이다.

---

# 역할, 책임, 협력 관점에서의 객체지향

## 요청과 응답으로 구성된 협력

- 하나의 문제를 위해선 다수의 사람 또는 역할이 필요하기 때문에 한 사람에 대한 요청이 다른 사람에 대한 요청으로 이루어지는 것은 일반적이다. ( 연쇄적으로 요청이 발생한다는 뜻 )
- 따라서 요청에 대한 응답도 요청의 반대 방향으로 연쇄적으로 이루어진다.

→ 연쇄적인 요청과 연쇄적인 응답을 통해서 하나의 목표를 다 같이 해결해나간다.

## 객체지향에서 역할의 중요한 개념

- 여러 사람이 동일한 역할을 수행할 수 있다.
→ 어떤 캐시어가 주문을 받던, 손님은 커피만 받으면 된다. 또한 캐시어가 그만두면 다른 캐시어를 고용하면 된다.
- 역할은 **대체 가능**하다.
→ 두명이 동일한 역할을 수행할 수 있다면, 요청자의 입장에선 둘 중 어떤 사람이 역할을 수행하더라고 상관없다.
- 책임을 수행하는 방법은 자율적으로 선택할 수 있다
→ 바리스타가 갈아져 있는 원두를 쓰던, 직접 원두를 갈던 결국 커피만 만들면 되는 것이다.
즉, 어떤 요청이 들어와도 서로 다른 방식으로 응답 능력을 기르면 된다. **(다형성)**
- 한사람이 동시에 여러 역할을 수행할 수 있다.
→ 캐시어가 바리스타의 역할까지 수행해도 손님의 커피 요청에 응답알 수 있다.

## 역할이라는 것은 책임을 내포하고 있다.

- 바리스타라는 역할은 커피를 제조할 책임이 있다.

## 실세계와 프로그램 세계

### 사람 → 객체    요청 → 메세지    요청을 처리하는 방법 → 메서드

### 사람은 공통된 목표를 위해 협력하지만, 객체는 하나의 어플리케이션을 위해 협력.

### → 결론적으로, 시스템은 역할과 책임을 수행하는 객체로 분할되고 시스템의 기능은 객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현됨.

## 객체지향의 설계

### 책임은 객체지향 설계의 품질을 결정하는 가장 중요한 요소

→ 적절한 객체에게 적절한 책임을 할당해야 함.
→ 책임이 불분명한 객체로 이루어진 어플리케이션의 미래는 역시 불분명.

### 역할은 유연하고 재사용 가능한 협력 관계를 구축하는데 중요한 설계 요소

→ 대체 가능한 역할과 책임은 객체지향 패러다임의 중요한 기반을 제공하는 다형성과도 깊이 연관됨.

---

# 협력 속에 사는 객체

### 객체지향 APP의 윤곽을 결정하는 것은 역할, 책임 협력이지만
→ 실제로 협력하는 주체는 객체임.

### 한 프로그램은 매우 복잡하기 때문에 프로그램의 일을 객체의 책임들로 세분화하여 협력
→ 객체지향 APP의 아름다움을 결정하는 것은 협력
→ 하지만 실제로 협력하는 것은 객체이기 때문에, 협력의 품질 = 객체의 품질

## 객체의 두가지 덕목

### 1. 협력적

- 객체는 다른 객체의 요청에 귀 기울이고 도움에 요청을 할 열린 마음을 지녀야 한다.
→ 듣지 않고 혼자 모든 것을 처리하려는 하나의 객체는 결국 복잡한 내구도에 의해 자멸
- 협력적이라는 것은 다른 객체에 수동적이고 명령에 복종한다는 것이 아닌 
**스스로의 응답 방식을 통해 다른 객체의 요청에 응답한다는 것이다.**

### 2. 자율적

- 자기 스스로의 원칙에 따라 어떤 일을 하거나 자기 스스로를 통제하여 절제하는 것

### → 따라서 객체 지향의 설계는
     다른 객체와 조화롭게 협력할 수 있을 만큼 충분히 개방적
     협력에 참여하는 방법을 스스로 결정할 수 있을만큼 충분히 자율적

## 상태와 행동을 함께 지닌 자율적인 객체

### 객체의 정의 : 상태와 행동을 함께 지닌 실체

→ 어떤 행동을 하려면 행동을 위한 상태를 가지고 있어야 함

### 객체의 내부와 외부

내부 : 객체의 **사적인** 부분으로 외부에서는 일체 간섭할 수 없도록 **차단**

외부 : **접근이 허락된 수단**을 통해 외부와 소통

**→ 다른 객체가 외부에서 무엇을 소통하는지는 알 수 있지만 어떻게 수행하는지에 대해서는 알 수 없게 해야함**

**→ 데이터와 프로세스를 하나의 틀 안에 묶음**

## 협력과 메세지

### 실세계에선 여러 가지 방법으로 소통하지만 객체들은 **메세지**라는 하나의 수단으로 소통

→ 요청 하는 것 : 메세지 전송 (송신자)
→ 요청 받는 것 : 메세지 수신 (수신자)

## 메서드와 자율성

### 메서드

수신된 메세지를 처리하는 방법 → 클래스 내부에 선언된 함수 또는 프로시저

### 외부의 요청에 따라서 메세지를 처리하는 구체적인 방법인 메서드를 분리하는 것이 객체의 자율성을 높이는 핵심 메커니즘

---

# 객체지향의 본질

### 시스템을 상호작용하는 자율적인 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법

### 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체

### 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력하고 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.

### 객체는 다른 객체와 협력하기 위해 메세지라는 수단을 이용하고 메세지를 수신한 객체는 메세지를 처리하는데 적합한 메서드를 자율적으로 선택

## 객체를 지향하라

### 사람들의 지나친 클래스에 대한 중요성 부여

→ 클래스가 객체 지향의 핵심이 아님. ( 중요하지 않다는 것은 절대 아님 )

→ 코드를 담는 클래스의 관점에서 **메세지를 주고 받는 객체의 관점으로 사고의 중심을 전환**해야 함.

→ 클래스는 객체들의 협력 관계를 코드로 옮기는 도구에 불과.

### 객체지향의 핵심은 클래스들의 정적인 관계가 아니라, 메시지를 주고 받는 객체들의 동적인 관계

### 클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중해야 함.