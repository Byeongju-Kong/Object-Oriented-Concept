# 타입과 추상화

# 추상화를 통한 복잡성 극복

### 엄청나게 복잡한 현실을 그대로 수용하기에는 인간의 인지능력과 저장공간은 부족

→ 본능적으로 이해하기 쉽고 예측 가능한 수준으로 **현실을 분해하고 단순화해야한다.**

## 추상화

### 💡 정의 : 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤(단순화)으로써 복잡도를 극복하는 방법

### ✔️현실의 불필요한 부분을 제거해가면서 사물의 본질을 드러내게 하는 과정

→ 불필요한 부분을 제거하기 때문에, **현실에 존재하는 복잡성을 극복**할 수 있다.
→ 필요한 부분, 현실에서 분석 혹은 파악하려는 것의 맹점을 더 두드러지게 할 수 있다.

### 추상화가 이뤄지는 두가지 차원

✔️ 첫번째 차원 : 구체적인 사물들 간의 **공통점은 취하고 차이점은 버리는** 일반화

✔️ 두번째 차원 : 중요한 부분을 강조하기 위해 **불필요한 세부사항을 제거**

### → 객체지향 패러다임은 객체라는 추상화를 통해 현실의 복잡성을 극복

---

# 객체지향과 추상화

## 그룹으로 나누어 단순화하기

어떤 공간에 서로 다른 국가의 사람 100명과 서로 다른 종류의 50마리의 개가 있다고 생각해보자.
이들은 모두 다른 150개의 객체이다. 하지만 사람 그리고 개, 이 두가지 그룹으로 나누어 단순화할 수 있다.

→ 세상에는 수 많은 특징들을 가진 여러 객체들이 있지만, 이런 **복잡성을 그룹 단순화를 통해 효과적으로 감소**시킬 수 있다.

## 개념

### ✔️ 공통점을 기반으로 객체들을 분류하기 위한 일종의 체
✔️ 객체가 어떤 개념으로 나뉜 그룹의 일원이 될 때, 그 객체는 해당 개념의 인스턴스

## 개념의 세가지 관점

### 1. 심볼

개념을 가르키는 **간략한 이름이나 명칭**
ex) 인간, 개, 고양이

### 2. 내연

**개념의 완전한 정의**. 내연의 의미를 이용해 객체가 개념에 속하는지에 대한 여부를 확인가능
개념을 이루는 집합의 공통적인 특징이라고 생각하면 편할 것
ex) 인간은 팔다리가 두개씩 있고, 눈이 두개고, 코가 하나고 등등

### 3. 외연

**개념에 속하는 모든 객체에 집합** (set)
ex) 철수, 영희, Tom, Alice 등등

## 개념은 객체를 분류하기 위한 틀

### 분류

→ 객체에 특정한 개념을 적용하는 작업
→ 특정 객체를 **특정 개념의 집합에 포함시키거나 포함시키지 않는** 작업

### ✔️ 객체를 적절한 개념에 따라 분류를 해야 유지보수에 용이하고 변화에 유연한 대처 가능

### 💡더 중요한 것은 적절한 분류 체계는 개발자의 머리속에서 객체를 쉽게 찾고 쉽게 조작할 수 있는 정신적인 지도를 제공

---

# 타입

## 타입은 개념이다

### ✔️ 타입은 개념과 동일한 개념으로, 공통점을 기반으로 객체들을 묶기 위한 틀

❗️타입은 컴퓨터 공학자들의 '개념'과 동일한 용어로 심볼, 내연, 외연을 이용해 서술 가능

## 데이터 타입

실제 데이터가 저장되는 **메모리**를 들여다보면, 타입이라는 것은 존재하지 않고 **0과 1이라는 숫자뿐**이다.

이렇게 0과 1만을 보고는 **데이터의 종류를 구분할 수 없기 때문**에, **데이터를 타입별로 분리하고 타입시스템**이라는 것이 생겨나기 시작했다
→ 메모리 속의 0과 1에 대해 수행 가능한 작업과 불가능한 작업을 구분함으로써 **데이터의 오용 방지**

### ✔️ 타입은 데이터가 어떻게 사용되느냐에 관한 것이다( 어떤 Operation이 적용가능한가 )

→ 특정 데이터가 **4칙연산이 가능하면** 숫자형, 두 문자를 붙혀 문자열을 만들 수 있으면 문자형

### ✔️ 타입에 속한 데이터를 어떻게 메모리에 표현하는지는 외부로부터 철처하게 감춰진다

→ 개발자는 숫자 타입 데이터가 메모리에 **어떻게 저장되는지 몰라도, 어떤 연산자를 사용해야하는지만 알면** 숫자 타입 데이터를 사용하는데 지장이 없다

### 💡 데이터 타입은 메모리 속 데이터 종류를 분류하기 위한 메모리 집합에 관한 메타 데이터

## 객체와 타입

객체 지향에서 객체는 일종의 데이터처럼 사용된다. 수많은 객체들을 타입에 따라 분류하고 타입에 이름을 붙히는 것은 **새로운 데이터타입을 선언하는 것**이다.

### ✔️ 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동

→ 객체지향에서의 핵심은 '객체가 협력을 위해 어떤 행동을 하는지'이기 때문에, **객체 구분의 핵심도 역시 객체의 책임 또는 행동**이다.

### ✔️ 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다

→ 객체가 **행동을 효과적으로 수행**하기만 한다면 **내부 표현 방식은 어떻게되어도 상관없다**.

### 💡 객체의 타입은 내부의 표현이 어떻든 동일하게 행동하면 동일한 타입이다

## 행동이 우선이다

### ✔️ 같은 타입에 속한 객체는 행동이 동일하다면 서로 다른 데이터를 가질 수 있다

→ 여기서 동일한 행동은 **동일한 책임**을 의미하고 동일한 책임은 **동일한 메세지**를 수신하고 처리할 수 있다는 것.
→ 동일한 메세지를 **처리하는 방법은 객체마다 다를 수 있다. (다형성)**

💡 동일한 메세지를 서로 다른 방식으로 처리하기 위해서는 결국 동일한 **메시지를 수신할 수 있어야하는데, 이는 동일한 타입에 속해야 가능하다.**

### ✔️내부표현 방식 말고 행동만을 고려하는 것은 외부에 데이터를 감춰야한다는 것이다.

→ 훌륭한 객체지향 설계는 **행동만을 외부에 공개하고 데이터는 내부에 감춰야한다 (캡슐화).** 

### 행동에 따라 객체를 분류하는 방법

✔️ 객체가 외부에 제공해야하는 행동(책임)을 생각 : **책임 주도 설계 (Responsibility-Driven Design)**

1. **객체가 외부에 제공해야하는 책임 결정**
2. **책임을 수행하는 데 적합한 데이터 결정**
3. **데이터를 책임을 수행하는 데 필요한 외부 인터페이스 뒤로 캡술화**

---

# 타입의 계층

MapleStory라는 게임에서 암석으로 이루어져있고 혼자서 걸어다닐 수 있 '골렘'이라는 몬스터를 생각해보자. 우리는 이를 암석이라는 타입으로 분류할 수 있다. 그런데 직접 걸어다니지 못하는 '자연의 암석'도 게임속에 존재한다. 이 역시도 암석이라는 타입으로 분류할 수 있다. 둘의 외향은 암석으로 비슷하지만 '골렘'은 자연의 암석과 비교해서 혼자 걸어다닐 수 있기 때문에, 암석몬스터라는 타입으로 분류하는 것이 옳다. 이 관계를 아래와 같이 표현할 수 있다.

_ _ _ _ _ _ _ _ _ _ _ _ 암석  _ _ _ _ _ _ _ _ _ _ _ _ _ 

|                                                                                      |
|                      _ _ _ _ _ _ _ _ _ _ _ 암석몬스터 _ _ _   |
|                      |                                                           |   |
|                      |                                                           |   |
|                      |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|   |
****_ _ _ _ _ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |

→ 암석 몬스터의 외연집합은 암석의 외연집합의 부분집합으로 표현할 수 있다.
→ 암석은 암석몬스터를 포괄하는 일반적인 개념, 암석몬스터는 암석보다 특화된 행동을 하는 특수한 개념이다.

## 일반화/특수화 관계

### ✔️ 타입과 타입사이에는 일반화/특수화 관계가 존재할 수 있다.

### ✔️ 일반화와 특수화는 동시에 일어난다.

→ 일반화와 특수화는 상대적인 것이므로, 반드시 일반적인 것과 상대적인 것이 필요하다

### ✔️일반화/특수화 관계를 결정하는 것은 객체 상태를 표현하는 데이터가 아닌 행동이다.

→ **일반적인 타입**은 자신이 포함하는 타입들이 가진 모든 행동들 중에 일부 **공통적인 행동만을 가지는 타입**

→ **특수적인 타입**은 자신을 포함하는 타입의 일반적인 행동에 더해 **자신만의 특수한 행동도 가지는 타입**

### 💡 일반화/특수화 관계에서 행동의 수는 외연 집합의 원소 수에 반비례한다.

→ 특수한 행동을 추가적으로 가지는 특수 타입은 일반 타입에 비해 외연 집합의 원소수가 적다

→ 일반적인 행동만을 가지는 일반 타입은 특수 타입에 비해 외연 집합의 원소수가 많다.

## 슈퍼타입과 서브타입

### ✔️ 일반화/특수화관계를 슈퍼/서브 관계로 표현할 수 있다.

### 💡 서브타입은 슈퍼타입의 행동을 모두 할 수 있어야한다.

→ 서브타입은 슈퍼타입의 행위를 할 수 있기 때문에, 슈퍼타입을 대체할 수 있어야한다.

## 일반화는 추상화를 위한 도구다

추상화의 두번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거하는 것이었다.
누군가가 '자연의 암석'과 같이 있는 '골렘'을 보았을 때, "뭐야 암석들 밖에 없네?"라고 걸을 수 있다는 골렘의 특수 행동을 무시하고 골렘을 일반화 시킬 수 있다.

---

# 정적 모델

## 타입의 목적

### ✔️**시간에 따라 동적으로 변하는 객체의 복잡성을 극복**하기 위해 타입을 사용

'공병주'라는 객체는 햄버거를 먹고(+3kg) 굶음(-2kg)에 따라 몸무게라는 '상태'가 동적으로 변한다. 햄버거를 먹고 굶음에 따라 발생할 수 있는 모든 몸무게들을 생각하는 것이 아니라, '공병주'라는 객체의 **'행동은 햄버거를 먹고, 굶는 것이 있고 몸무게라는 객체는 임의의 값을 가질수 있다'라고 시간에 독립적인 정적인 모습**으로 공병주를 생각할 수 있다.

## 결국 타입은 추상화다

### ✔️ 위처럼 불필요한 시간과 상태변화라는 요소를 제거하고 시간에 독립적인 정적인 관점에서 객체를 묘사할 수 있다.

### ✔️ 상태가 어떻게 변할지를 생각하는 것이 아니라, 상태가 변할 수 있다는 가능성에 집중

## 동적 모델과 정적 모델

### 동적 모델

✔️ **시간에 따라 객체가 어떻게 변하고 어떻게 행동하는지**를 포착하는 모델

### 정적 모델

✔️ 객체가 가질 수 있는 **모든 상태와 모든 행동을 시간에 독립적으로 표현하고 변화의 가능성에만 집중**하는 모델
✔️동적으로 변하는 객체의 상태가 아닌 **객체가 속한 타입의 정적인 모습을 표현**

### 동적인 관점과 정적인 관점의 적절한 혼용

✔️ 객체지향 **프로그래밍**을 하는 것은 시스템을 **정적인 관점**에서 접근하는 것
✔️ 프로그램을 **실행**하거나 **디버깅**하여 객체의 상태변경을 추적하는 것은 **동적인 관점**

## 클래스

### 타입은 클래스가 아니다

✔️ 타입은 객체를 분류하기 위한 개념이고, 클래스는 타입을 구현하기 위한 메커니즘이다.

❗️JS와 같은 언어에는 클래스가 존재하지 않는다.